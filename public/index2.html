<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
    <meta http-equiv="Pragma" content="no-cache"/>
    <meta http-equiv="Expires" content="0"/>
    <meta name="viewport" content="minimal-ui">
    <title></title>
    <style type="text/css">
        html, body { height: 100%; margin: 0; padding: 0; }
        #map { height: 0%; }
        #chart_div { height: 0%; }
        #speeds_div { height: 100%; }
        .portrait {
            -webkit-transform: rotate(90deg);
            -webkit-transform-origin: 200px 190px;
        }
        .portrait-onready {
            -webkit-transform: rotate(90deg);
            -webkit-transform-origin: 165px 150px;
        }
    </style>
    <script type="text/javascript" src="https://www.google.com/jsapi"></script>
    <script type="text/javascript" src="https://maps.google.com/maps/api/js?key=AIzaSyDl9TGC98BJn4hMIHL5o7umITbXqF2YbzQ"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script type="text/javascript" src="js/moment.js"></script>
    <script>
                  // JavaScript Document
                  // TODO: Code cleaning up.
                  // TODO: Mapa que sea optativo para mostrar o mostrarlo de una forma que sea user friendly
                  // TODO: Recomendacion online segun altura del tipo de carrera: rapido, loma, constante, ...
                  // TODO: Opcion para guardar y cargar mapas

                  var map = null;
                  var chart = null;
                  var ida = true;
                  var INTERVAL = 100; // Refresh Interval

                  var geocoderService = null;
                  var elevationService = null;
                  var directionsService = null;

                  var mousemarker = null;
                  var markers = [];
                  var polyline = null;
                  var elevations = null;
                  var id_watch = 0;
                  var prevCoord = false;
                  var sessionDistance = 0;
                  var sessionAvgSpeed = 0;
                  var intervalAvgSpeed = 0;
                  var start = null;
                  var speeds = [];
                  var speedsChart = null;
                  var speedData = null;


                  var SAMPLES = 256;

                // Hacer que siempre este a 90 al estar en portrait. TODO: Bug
                $(window).bind('orientationchange', function(e, onready){
                       if(onready){
                           $(document.body).addClass('portrait-onready');
                       }
                       if (Math.abs(window.orientation) != 90){
                           $(document.body).addClass('portrait');
                       }
                       else {
                           $(document.body).removeClass('portrait').removeClass('portrait-onready');
                       }
                });
                $(window).trigger('orientationchange', true); // fire the orientation change event at the start, to make sure


                  // Load the Visualization API and the piechart package.
                  google.load("visualization", "1", {packages: ["corechart"]});

                  // Set a callback to run when the Google Visualization API is loaded.
                  google.setOnLoadCallback(initialize);

                  var marker;
                  var route = [];
                  var returnRoute = [];


                  function getRandomArbitrary(min, max) {
                      return Math.random() * (max - min) + min;
                  }

                  function setSpeed(position) {
                    if (mobileAndTabletcheck()) {
                        if (position.coords.speed !== null) {
                            // convierto de m/s a km/h => 3600/1000 = 3.6
                            sessionAvgSpeed = position.coords.speed * 3.6;
                        } else {
                            sessionAvgSpeed = 0;
                        }
                    }
                    else{
                        sessionAvgSpeed = getRandomArbitrary(0, 15);
                    }
                  }

                  function placeMarker(location) {
                      marker = new google.maps.Marker({
                          position: location,
                          map: map
                        });
                      route.push(marker);
                      returnRoute.push(marker);
                  }

                  function mobileAndTabletcheck() {
                      var check = false;
                      (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
                      return check;
                  }

                  function initialize() {

                    speedsChart = new google.visualization.AreaChart(document.getElementById('speeds_div'));

                    speedData = new google.visualization.DataTable();
                    speedData.addColumn('string', 'test');
                    speedData.addColumn('number', 'Current Speed');
                    speedData.addColumn({type: 'string', role: 'style'});

                    if (navigator.geolocation) {
                      wpid=navigator.geolocation.watchPosition(updatePositionOK, failureGetPosition);
                      // setInterval(updatePosition, INTERVAL);
                    } else {
                      // Browser doesn't support Geolocation
                      var infoWindow = new google.maps.InfoWindow({map: map});
                      handleLocationError(false, infoWindow, map.getCenter());
                    }

                  }

                  function failureGetPosition() {
                      handleLocationError(true, infoWindow, map.getCenter());
                  }

                  function updatePositionOK(position) {
                          setSpeed(position);
                          updateSpeedChart();
                  }

                  function updatePosition() {
                        navigator.geolocation.getCurrentPosition(updatePositionOK, failureGetPosition);
                  }

                  function BackButton(controlDiv, map) {

                      // Set CSS for the control border.
                      var controlUI = document.createElement('div');
                      controlUI.style.backgroundColor = '#fff';
                      controlUI.style.border = '2px solid #fff';
                      controlUI.style.borderRadius = '3px';
                      controlUI.style.boxShadow = '0 2px 6px rgba(0,0,0,.3)';
                      controlUI.style.cursor = 'pointer';
                      controlUI.style.marginBottom = '22px';
                      controlUI.style.textAlign = 'center';
                      controlUI.title = 'Ida';
                      controlDiv.appendChild(controlUI);

                      // Set CSS for the control interior.
                      var controlText = document.createElement('div');
                      controlText.style.color = 'rgb(25,25,25)';
                      controlText.style.fontFamily = 'Roboto,Arial,sans-serif';
                      controlText.style.fontSize = '16px';
                      controlText.style.lineHeight = '38px';
                      controlText.style.paddingLeft = '40px';
                      controlText.style.paddingRight = '40px';
                      controlText.style.paddingBottom = '40px';
                      controlText.style.paddingTop = '20px';
                      controlText.innerHTML = 'Ida';
                      controlUI.appendChild(controlText);

                      // Setup the click event listeners: simply set the map to Chicago.
                      controlUI.addEventListener('click', function() {
                          if (ida) {
                            controlText.innerHTML = 'Vuelta';
                          } else {
                            controlText.innerHTML = 'Ida';
                          }
                          ida = (!ida);
                      });

                    }

                  function geo_success(position){
                    document.title=position.coords.speed;
                  }


                  function RouteButton(controlDiv, map) {

                      // Set CSS for the control border.
                      var controlUI = document.createElement('div');
                      controlUI.style.backgroundColor = '#fff';
                      controlUI.style.border = '2px solid #fff';
                      controlUI.style.borderRadius = '3px';
                      controlUI.style.boxShadow = '0 2px 6px rgba(0,0,0,.3)';
                      controlUI.style.cursor = 'pointer';
                      controlUI.style.marginBottom = '22px';
                      controlUI.style.textAlign = 'center';
                      controlUI.title = 'Route';
                      controlDiv.appendChild(controlUI);

                      // Set CSS for the control interior.
                      var controlText = document.createElement('div');
                      controlText.style.color = 'rgb(25,25,25)';
                      controlText.style.fontFamily = 'Roboto,Arial,sans-serif';
                      controlText.style.fontSize = '16px';
                      controlText.style.lineHeight = '38px';
                      controlText.style.paddingLeft = '40px';
                      controlText.style.paddingRight = '40px';
                      controlText.style.paddingTop = '20px';
                      controlText.style.paddingBottom = '40px';
                      controlText.innerHTML = 'Route';
                      controlUI.appendChild(controlText);

                      // Setup the click event listeners: simply set the map to Chicago.
                      controlUI.addEventListener('click', function() {
                            start = last = moment();
                            loadRoute();
                            if (mobileAndTabletcheck()) {
                                $('#chart_div').height('50%');
                                $('#speeds_div').height('35%');
                                $('#map').height('15%');
                            }

                      });

                    }

                  function rad(x) {return x*Math.PI/180;}

                  function updateSpeedChart(){
                    // get the last 400 rows only
                    if (speedData.getNumberOfRows() > 400) {
                        speedData.removeRow(0);
                    }
                    speedData.addRow(['', sessionAvgSpeed, 'color: #0000FF']);
                    document.getElementById('speeds_div').style.display = 'block';
                    speedsChart.clearChart();
                    speedsChart.draw(speedData, {
                      height: '100%',
                      legend: 'none',
                      titleY: 'Current Speed:'+sessionAvgSpeed,
                      focusBorderColor: '#00ff00'
                    });
                  }

                  function find_closest_marker( pos ) {
                    var lat = pos.lat;
                    var lng = pos.lng;
                    var R = 6371; // radius of earth in km
                    var distances = [];
                    var closest = -1;
                    var init = 0;
                    var elevationsVar = null;
                    if (ida)
                        elevationsVar = elevations;
                    else
                        elevationsVar = returnElevations;


                    var end = elevationsVar.length;
                    for( var i = 0; i < elevationsVar.length; i++ ) {
                            var mlat = elevationsVar[i].location.lat();
                            var mlng = elevationsVar[i].location.lng();
                            var dLat  = rad(mlat - lat);
                            var dLong = rad(mlng - lng);
                            var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                                Math.cos(rad(lat)) * Math.cos(rad(lat)) * Math.sin(dLong/2) * Math.sin(dLong/2);
                            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                            var d = R * c;
                            distances[i] = d;
                            if ( closest == -1 || d < distances[closest] ) {
                                closest = i;
                            }
                    }
                    var data = new google.visualization.DataTable();
                    data.addColumn('string', 'test');
                    data.addColumn('number', 'Altura');
                    data.addColumn({type: 'string', role: 'style'});

                    for (var i = 0; i < elevationsVar.length; i++) {
                            if (i<closest)
                                data.addRow(['', elevationsVar[i].elevation, 'color: #00ff00']);
                            else{
                                if (i> closest)
                                    data.addRow(['', elevationsVar[i].elevation, 'color: #ff0000']);
                                 else{
                                    data.addRow(['', elevationsVar[i].elevation, 'color: #00ff00']);
                                 }
                            }

                    }
                    document.getElementById('chart_div').style.display = 'block';
                    chart.clearChart();
                    chart.draw(data, {
                      height: '100%',
                      legend: 'none',
                      titleY: 'Height',
                      focusBorderColor: '#00ff00'
                    });

                    chart.setSelection([]);
                    chart.setSelection([{column:1,row:closest+1}]);
                  }

                  // Takes an array of ElevationResult objects, draws the path on the map
                  // and plots the elevation profile on a GViz ColumnChart
                  function plotElevation(results) {
                    elevations = results;

                    var path = [];
                    for (var i = 0; i < results.length; i++) {
                      path.push(elevations[i].location);
                    }

                    if (polyline) {
                      polyline.setMap(null);
                    }

                    polyline = new google.maps.Polyline({
                      path: path,
                      strokeColor: "#FF0000",
                      map: map});

                  }

                  function plotReturnRouteElevation(results) {
                    returnElevations = results;

                    var path = [];
                    for (var i = 0; i < results.length; i++) {
                      path.push(returnElevations[i].location);
                    }

                    if (polyline) {
                      polyline.setMap(null);
                    }

                    polyline = new google.maps.Polyline({
                      path: path,
                      strokeColor: "#FF0000",
                      map: map});

                  }

                  // Remove the green rollover marker when the mouse leaves the chart
                  function clearMouseMarker() {
                    if (mousemarker != null) {
                      mousemarker.setMap(null);
                      mousemarker = null;
                    }
                  }

                  // Add a marker and trigger recalculation of the path and elevation
                  function addMarker(latlng, doQuery) {

                      var marker = new google.maps.Marker({
                        position: latlng,
                        icon: "no",
                        map: map,
                      })

                      google.maps.event.addListener(marker, 'dragend', function(e) {
                        updateElevation();
                      });

                      markers.push(marker);

                      if (doQuery) {
                        updateElevation();
                      }

                  }

                  // Trigger the elevation query for point to point
                  // or submit a directions request for the path between points
                  function updateElevation() {
                    if (markers.length > 1) {
                      var travelMode = 'walking';
                      if (travelMode != 'direct') {
                        calcRoute(travelMode);
                      } else {
                        var latlngs = [];
                        for (var i in markers) {
                          latlngs.push(markers[i].getPosition())
                        }
                        elevationService.getElevationAlongPath({
                          path: latlngs,
                          samples: SAMPLES
                        }, plotElevation);
                      }
                    }
                  }

                  function updateReturnPathElevation() {
                    if (markers.length > 1) {
                      var travelMode = 'walking';
                      if (travelMode != 'direct') {
                        calcReturnRoute(travelMode);
                      } else {
                        var latlngs = [];
                        for (var i in markers) {
                          latlngs.push(markers[i].getPosition())
                        }
                        elevationService.getElevationAlongPath({
                          path: latlngs,
                          samples: SAMPLES
                        }, plotReturnRouteElevation);
                      }
                    }
                  }




                  // Submit a directions request for the path between points and an
                  // elevation request for the path once returned
                  function calcRoute(travelMode) {
                    var origin = markers[0].getPosition();
                    var destination = markers[markers.length - 1].getPosition();

                    var waypoints = [];
                    for (var i = 1; i < markers.length - 1; i++) {
                      waypoints.push({
                        location: markers[i].getPosition(),
                        stopover: true
                      });
                    }

                    var request = {
                      origin: origin,
                      destination: destination,
                      waypoints: waypoints
                    };

                    switch (travelMode) {
                      case "bicycling":
                        request.travelMode = google.maps.DirectionsTravelMode.BICYCLING;
                        break;
                      case "driving":
                        request.travelMode = google.maps.DirectionsTravelMode.DRIVING;
                        break;
                      case "walking":
                        request.travelMode = google.maps.DirectionsTravelMode.WALKING;
                        break;
                    }

                    directionsService.route(request, function(response, status) {
                      if (status == google.maps.DirectionsStatus.OK) {
                        elevationService.getElevationAlongPath({
                          path: response.routes[0].overview_path,
                          samples: SAMPLES
                        }, plotElevation);
                      } else if (status == google.maps.DirectionsStatus.ZERO_RESULTS) {
                        alert("No se encuentra ruta entre estos dos puntos");
                      } else {
                        alert("Fallo de direcciones");
                      }
                    });
                  }


                  function calcReturnRoute(travelMode) {
                    var origin = markers[0].getPosition();
                    var destination = markers[markers.length - 1].getPosition();

                    var waypoints = [];
                    for (var i = 1; i < markers.length - 1; i++) {
                      waypoints.push({
                        location: markers[i].getPosition(),
                        stopover: true
                      });
                    }

                    var request = {
                      origin: origin,
                      destination: destination,
                      waypoints: waypoints
                    };

                    switch (travelMode) {
                      case "bicycling":
                        request.travelMode = google.maps.DirectionsTravelMode.BICYCLING;
                        break;
                      case "driving":
                        request.travelMode = google.maps.DirectionsTravelMode.DRIVING;
                        break;
                      case "walking":
                        request.travelMode = google.maps.DirectionsTravelMode.WALKING;
                        break;
                    }

                    directionsService.route(request, function(response, status) {
                      if (status == google.maps.DirectionsStatus.OK) {
                        elevationService.getElevationAlongPath({
                          path: response.routes[0].overview_path,
                          samples: SAMPLES
                        }, plotReturnRouteElevation);
                      } else if (status == google.maps.DirectionsStatus.ZERO_RESULTS) {
                        alert("No se encuentra ruta entre estos dos puntos");
                      } else {
                        alert("Fallo de direcciones");
                      }
                    });
                  }

                  function loadRoute() {
                    reset();
                    map.setMapTypeId(google.maps.MapTypeId.ROADMAP);
                    var bounds = new google.maps.LatLngBounds();
                    for (var i = 0; i < route.length; i++) {
                      var latlng = new google.maps.LatLng(
                        route[i].getPosition().lat(),
                        route[i].getPosition().lng()
                      );
                      addMarker(latlng, false);
                      bounds.extend(latlng);
                    }
                    updateElevation();
                    // Return Route
                    returnRoute.reverse();
                    reset();
                    bounds = new google.maps.LatLngBounds();
                    for (var i = 0; i < returnRoute.length; i++) {
                      var latlng = new google.maps.LatLng(
                        returnRoute[i].getPosition().lat(),
                        returnRoute[i].getPosition().lng()
                      );
                      addMarker(latlng, false);
                      bounds.extend(latlng);
                    }
                    updateReturnPathElevation();
                  }

                  function cleanupRoutes(){
                    for (var i in route) {
                      route[i].setMap(null);
                    }
                    route = [];
                  }

                  function clearMarkers() {
                    for (var i in markers) {
                      markers[i].setMap(null);
                    }
                  }
                  // Clear all overlays, reset the array of points, and hide the chart
                  function reset() {
                    if (polyline) {
                      polyline.setMap(null);
                    }

                    for (var i in markers) {
                      markers[i].setMap(null);
                    }

                    markers = [];

                    document.getElementById('chart_div').style.display = 'none';
                    document.getElementById('speeds_div').style.display = 'none';
                  var locations = [
                    ["Partida",
                    "Partida",
                    "-38.005022",
                    "-57.542555",
                    "img/largada.png"
                    ]
                    ];

                gmarkers = [];

                function createMarker(latlng, html, icon) {
                    var marker = new google.maps.Marker({
                        position: latlng,
                        icon: icon,
                        map: map
                    });

                    return marker;
                }

                for (var i = 0; i < locations.length; i++) {
                    gmarkers[locations[i][0]] =
                    createMarker(new google.maps.LatLng(locations[i][2], locations[i][3]), "<table style='width:100%;'><tr><td>" + locations[i][0] + "</td></tr></table>", locations[i][4]);
                }

                }

                function handleLocationError(browserHasGeolocation, infoWindow, pos) {
                  infoWindow.setPosition(pos);
                  infoWindow.setContent(browserHasGeolocation ?
                                        'Error: The Geolocation service failed.' :
                                        'Error: Your browser doesn\'t support geolocation.');
                }
    </script>
</head>
<body>
<div id="map"></div>
<div id="speeds_div"></div>
<div id="chart_div"></div>
</body>
</html>